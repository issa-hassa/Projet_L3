<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Algo</title>
    <script language="javascript" type="text/javascript" src="libraries/p5.min.js"></script>
    <script language="javascript" type="text/javascript"></script>
    <script language="javascript" type="text/javascript" src="Graphe/graphesAlgo.js"></script>
    <script language="javascript" type="text/javascript" src="Graphe/arc.js"></script>
    <script language="javascript" type="text/javascript" src="Graphe/graphe.js"></script>
    <script language="javascript" type="text/javascript" src="Graphe/noeud.js"></script>
    <script language="javascript" type="text/javascript" src="Graphe/UnionFind.js"></script>
    <script language="javascript" type="text/javascript" src="Graphe/priorityQueue.js"></script>
    <script language="javascript" type="text/javascript" src="Graphe/laser.js"></script>
    <script language="javascript" type="text/javascript" src="circular.js"></script>
    <script language="javascript" type="text/javascript" src="utilitaire.js"></script>
    <script language="javascript" type="text/javascript" src="Paletcouleur.js"></script>
    <link rel="stylesheet" href="header.css">
    <link rel="stylesheet" href="Graphe/style.css">

</head>

<body>

    <header>
        <div class="logo">
            <div class="imgLogo"><img src="images/logo.png" alt=""> </div>
            <div class="nomLogo">
                <h3>AlgoSoupe</h3>
            </div>
        </div>
        <div class="onglets">
            <a href="web.html">Acceuil</a>
            <a href="Algo.html">Algorithmes</a>
            <a href="graphe.html">Graphe</a>

        </div>

    </header>
    <div class="p5" id="p5">
        <div class="choix" id="choix"></div>
        <div class="canvas" id="canvas"> </div>
        <div class="poids" id="poids"> </div>
        <div class="text" id="text"></div>

    </div>
    <div class="algo" id="algoDFS">
        <div class="alg">
            <h1>Parcours en profondeur</h1>
            Le parcours en profondeur est un algorithme de parcours d'un graphe <br>
            L'algorithme commence tout d'abord par un nœud quelconque le marque comme étant <strong> visité</strong>
            <br>,
            ensuite parmi les voisins du nœuds courant on choisit un nœud quelconque non visité, et on répète <br>
            jusqu'à ce qu'on tombe sur cul-de-sac et dans ce cas on revient sur nos pas
            (<strong>backtracking</strong>).<br>
            A cause de la nature récursive de l'algorithme une pile peut être utiliser pour l'implémenter, le processus
            de
            l'implémentation<br>
            du parcours en profondeur est similaire à celui du parcours en largeur:<br>
            
            &ensp; 1. Créer une pile vide.<br>
            &ensp; 2. Choisir un nœud quelconque comme point de départ de l'algorithme et l'ajouter dans la pile.<br>
            &ensp; 3. Ajouter un nœud non visité adjacent au nœud courant à la tête de la pile et le marquer comme
            étant
            visité.<br>
            &ensp; 4. Répéter 3 jusqu'à ce qu'il n'y est plus de nœud à visiter à partir du nœud courant (le nœud à
            la tête
            de la pile).<br>
            &ensp; 5. S'il reste aucun nœud, retirer le nœud à la tête de la pile.<br>
            &ensp; 6. Repeter 2,3 et 4 jusqu'à ce que la pile soit vide.<br>
            
            <h4>l'algorithme :</h4><br>
            &ensp;procedure DFS_iterative(G, v) is <br>
            &ensp;&ensp; let S be a stack<br>
            &ensp;&ensp; S.push(v)<br>
            &ensp;&ensp; while S is not empty do <br>
            &ensp;&ensp;&ensp; v = S.pop() <br>
            &ensp;&ensp;&ensp; if v is not labeled as discovered then <br>
            &ensp;&ensp;&ensp; label v as discovered <br>
            &ensp;&ensp;&ensp; for all edges from v to w in G.adjacentEdges(v) do<br>
            &ensp;&ensp;&ensp;&ensp; S.push(w)<br>




        </div>
        <div class="buttonFermer" id="buttonFermer1"> </div>
    </div>
    <div class="algo" id="algoBFS">
        <div>

            <h1>parcours en largeur</h1>
            Le parcours en largeur est un algorithme de parcours d'un graphe <br>
            L'algorithme commence tout d'abord par un nœud quelconque le marque comme étant <strong> visité</strong>
            <br>,
            ensuite on visite tous les voisins du nœuds courant non encore visité, et on répète avec les voisin du
            nœud
            courant: <br>


            &ensp; 1. Créer une file vide.<br>
            &ensp; 2. Choisir un nœud quelconque comme point de départ de l'algorithme et l'ajouter dans la file.<br>
            &ensp; 3. Retirer le nœud du début de la file pour le traiter.<br>
            &ensp; 4. Mettre tous ses voisins non explorés dans la file<br>
            &ensp; 5. Si la file n'est pas vide reprendre à l'étape 2.<br>


            <h4>l'algorithme :</h4><br>
            &ensp;procedure ParCoursLargeur(Graphe g, Sommet s) is <br>
            &ensp;&ensp; let Q be a queue <br>
            &ensp;&ensp; label root as explored<br>
            &ensp;&ensp; Q.enqueue(root)<br>
            &ensp;&ensp; while Q is not empty do <br>
            &ensp;&ensp;&ensp; v := Q.dequeue() <br>
            &ensp;&ensp;&ensp; for all edges from v to w in G.adjacentEdges(v) do <br>
            &ensp;&ensp;&ensp;&ensp; if w is not labeled as explored then <br>
            &ensp;&ensp;&ensp;&ensp;&ensp; label w as explored<br>
            &ensp;&ensp;&ensp;&ensp;&ensp; Q.enqueue(w)<br>


        </div>
        <div class="buttonFermer" id="buttonFermer2"> </div>
    </div>

    <div class="algo" id="ACM">
        <div>
            <h1>Arbre couvrant minimum</h1>
            Étant donnée un graphe connexe non orienté, un arbre couvrant de ce graphe est un arbre (un graphe connexe
            et
            acyclique)<br>
            qui connecte tous les nœuds. Un graphe peut avoir plusieurs arbres couvrants.<strong> Un abre couvrant de
            poids minimum</strong><br>
            pour un graphe pondéré, connexe, et non orienté est un arbre couvrant ayant un poids plus petit ou égal au
            poids de
            chaque arbre<br>
            couvrant possible du graphe.<br>
            Plusieurs algorithmes peuvent être utiliser pour avoir l'ACM d'un graphe (algorithme de Boruvka,
            l'algorithme de
            Prim, l'algorithme de Kruskal),<br>
            nous utiliserons l'algorithme de Kruskal.<br>
            <h4>Kruskal</h4><br>
            L'algorithme de Kruskal fonctionne de la manière suivante :<br>
            &ensp;&ensp; 1.Trier tous les arcs du graphe dans l'ordre croissant du poids.<br>
            &ensp;&ensp; 2.Prendre l'arc avec le plus petit poids et l'ajouter dans l'ACM si cet arc ne forme pas de
            cycle<br>
            &ensp;&ensp; (effectue cette vérification avec une structure de données Union-Find) dans l'ACM<br>
            &ensp;&ensp; 3. Répéter l'étape 2 pour tous les arcs du graphe. <br>
            <h5>Algorithme :</h5><br>
            Kruskal(G) :<br>
            1 &ensp;A := ø<br>
            2&ensp; pour chaque sommet v de G :<br>
            3&ensp; créerEnsemble(v)<br>
            4&ensp; trier les arêtes de G par poids croissant<br>
            5&ensp; pour chaque arête (u, v) de G prise par poids croissant :<br>
            6&ensp;&ensp; si find(u) ≠ find(v) :<br>
            7&ensp;&ensp;ajouter l'arête (u, v) à l'ensemble A<br>
            8&ensp;&ensp; union(u, v)<br>
            9&ensp; renvoyer A<br>

        </div>

        <div class="buttonFermer" id="buttonFermer3"> </div>
    </div>
    <div class="algo" id="tableDiv">
        <h1>Matrice d'adjacence </h1>
        <div class="table" id="table"></div>
    
        <div class="buttonFermer" id="buttonFermer4"> </div>
    </div>


</body>

</html>
